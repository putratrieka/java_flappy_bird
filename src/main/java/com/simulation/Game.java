/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package com.simulation;

import java.awt.Canvas;
import java.awt.Color;
import java.awt.Graphics;
import java.awt.image.BufferStrategy;
import java.util.List;
import java.util.stream.Collectors;

import com.simulation.adapter.KeyInput;
import com.simulation.enumaration.ID;
import com.simulation.gameobject.GameObject;
import com.simulation.gameobject.Obstacle;
import com.simulation.gameobject.Particle;
import com.simulation.gameobject.Score;
import com.simulation.manager.Handler;

public class Game extends Canvas implements Runnable {
	
	/**
	 * 
	 */
	private static final long serialVersionUID = 5632057234033616825L;
	
	private Thread thread;
	private boolean running = false;
	
	private static Handler handler;
	private Score score;
	
	public Game() {
		
		handler = new Handler();
		score = new Score(10, 10, ID.SCORE, handler);
		this.addKeyListener(new KeyInput(handler));
		new Window(Constanta.WIDTH, Constanta.HEIGHT, "SIMULATION", this);
		
		
		
		Particle particle = new Particle(0, 0, ID.PARTICLE, handler, score);
		Obstacle obs = new Obstacle(Constanta.WIDTH, 0, ID.OBSTACLE);
		Obstacle obs2 = new Obstacle(Constanta.WIDTH + Obstacle.DIST, 0, ID.OBSTACLE);
		Obstacle obs3 = new Obstacle(Constanta.WIDTH + Obstacle.DIST*2, 0, ID.OBSTACLE);
//		particle.setHeight(50);
//		particle.setWidth(50);
		handler.addObject(obs);
		handler.addObject(obs2);
		handler.addObject(obs3);
		
		handler.addObject(particle);
//		handler.addObject(new );
		
		
	}
	
	public static void reset() {
		List<GameObject> go = handler.object.stream().filter( g -> g.getId() == ID.OBSTACLE).collect(Collectors.toList());
		for (GameObject g : go) {
			handler.removeObject(g);
		}
		Obstacle obs = new Obstacle(Constanta.WIDTH, 0, ID.OBSTACLE);
		Obstacle obs2 = new Obstacle(Constanta.WIDTH + Obstacle.DIST, 0, ID.OBSTACLE);
		Obstacle obs3 = new Obstacle(Constanta.WIDTH + Obstacle.DIST*2, 0, ID.OBSTACLE);
//		particle.setHeight(50);
//		particle.setWidth(50);
		handler.addObject(obs);
		handler.addObject(obs2);
		handler.addObject(obs3);
		
	}
	
	public synchronized void start() {
		thread = new Thread(this);
		thread.start();
		running = true;
	}
	
	public synchronized void stop() {
		try {
			thread.join();
			running = false;
		} catch (Exception e) {
			e.printStackTrace();
			// TODO: handle exception
		}
	}
	
	/**
	 * Game loop 
	 */
	public void run() {
		long lastLoopTime = System.nanoTime();
//		double amountOfTicks = 60.0;
		
	    final double TARGET_FPS = 60.0;
	    final double OPTIMAL_TIME = 1000000000 / TARGET_FPS;
	    
	    double delta = 0;
	    long timer = System.currentTimeMillis();
	    long frames = 0;
	    while(running){
	        long now = System.nanoTime();
	        long updateLength = now - lastLoopTime;
	       
	        delta += updateLength / OPTIMAL_TIME;
	        lastLoopTime = now;
	        while (delta >= 1) {	
	        	tick();
	        	delta--;
	        }
	        
	        if (running) {
	        	render();
	        }
	        frames++;
	        
	        if (System.currentTimeMillis() - timer > 1000) {
	        	timer += 1000;
//	        	System.out.println("FPS " + frames);
	        	frames = 0;
	        }
	    }
	    stop();
	}
	
	private void tick() {
		handler.tick();
		score.tick();
	}
	
	private void render() {
		BufferStrategy bs = this.getBufferStrategy();
		if (bs == null) {
			this.createBufferStrategy(3);
			return;
		}
		
		Graphics g = bs.getDrawGraphics();
			
		g.setColor(Color.BLACK);
		g.fillRect(0, 0, Constanta.WIDTH, Constanta.HEIGHT);
		
		handler.render(g);
		score.render(g);
		
		g.dispose();
		bs.show();
		
	}

	public static void main (String args[]) {
		new Game();
	}


	
}
